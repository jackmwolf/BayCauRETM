% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_causal_recur.R
\docType{class}
\name{causal_recur_fit}
\alias{causal_recur_fit}
\alias{fit_causal_recur}
\alias{print.causal_recur_fit}
\alias{summary.causal_recur_fit}
\alias{plot.causal_recur_fit}
\title{Fit Bayesian Causal Recurrent and Terminal-Event Model}
\usage{
fit_causal_recur(
  data,
  K,
  id_col,
  time_col,
  treat_col,
  formula_T,
  formula_Y,
  prior = NULL,
  num_chains = 4,
  iter = 2000,
  control = list(adapt_delta = 0.95, max_treedepth = 15),
  cores = 1,
  verbose = TRUE,
  lag_col = "lagYk"
)

\method{print}{causal_recur_fit}(x, ...)

\method{summary}{causal_recur_fit}(
  object,
  pars_to_report = c("beta1", "theta1", "thetaLag", "betaL[1]", "thetaL[1]"),
  ci = c(0.025, 0.975),
  digits = 4,
  ...
)

\method{plot}{causal_recur_fit}(x, ...)
}
\arguments{
\item{data}{A long-format data.frame containing user-named identifier, time index,
treatment, outcomes, and covariates. The column names for ID, time, and treatment
are provided by \code{id_col}, \code{time_col}, and \code{treat_col}. The left-hand sides of
\code{formula_T} and \code{formula_Y} give the terminal-event and recurrent-count variables.}

\item{K}{Integer. Total number of discrete intervals in the study.}

\item{id_col}{Character scalar.Column name for the subject identifier.}

\item{time_col}{Character scalar. Name of the column that stores the discrete
time index per subject. Values in that column should be integers 1..K.}

\item{treat_col}{Character scalar. Column name for the binary treatment indicator (0/1).}

\item{formula_T}{A formula for the terminal-event sub-model, for example
\code{death_flag ~ lagYk + A + k_idx}. Terms on the right-hand side, excluding the
treatment column, form the design matrix for the terminal model.}

\item{formula_Y}{A formula for the recurrent-count sub-model, for example
\code{event_count ~ lagYk + A + k_idx}. Terms on the right-hand side, excluding the
treatment column, form the design matrices for the recurrent model (separately for
baseline rows with \code{k_idx == 1} and follow-up rows with \code{k_idx > 1}).}

\item{prior}{Named list of gAR(1) hyperparameters. Supported elements:
\code{eta_beta}, \code{sigma_beta}, \code{rho_beta}, \code{eta_gamma}, \code{sigma_gamma},
\code{rho_gamma}, \code{sigma_beta1}, \code{sigma_theta1}, \code{sigma_theta_lag}.
Missing entries fall back to internal defaults.}

\item{num_chains}{Integer. Number of MCMC chains (default \code{4}).}

\item{iter}{Integer. Total iterations per chain including warm-up
(default \code{2000}).}

\item{control}{List passed to \code{rstan::sampling()} (e.g.,
\code{list(adapt_delta = 0.95, max_treedepth = 15)}).}

\item{cores}{Integer. Number of CPU cores to use for sampling (passed to
\code{rstan::sampling()}).}

\item{verbose}{Logical. Index of whether to print progress messages (default \code{TRUE}).}

\item{lag_col}{Character scalar. Name of the lag indicator if lagged terms are used in either
formula. If the formulas include this name but the column is absent in \code{data}, the function
calls \code{preprocess_data()} to generate it within subject as an indicator based on
the previous interval outcome; otherwise the input is left unchanged. Default "lagYk".}

\item{x}{A \code{causal_recur_fit} object.}

\item{...}{further arguments passed to or from other methods.}

\item{object}{A \code{causal_recur_fit} object.}

\item{pars_to_report}{Character vector of parameter names (regex allowed).}

\item{ci}{Numeric vector of length 2. Credible interval bounds (default \code{c(0.025, 0.975)}).}

\item{digits}{minimal number of \emph{significant} digits, see
    \code{\link[base]{print.default}}.}
}
\value{
An object of class \code{causal_recur_fit} (list) with elements
\code{stan_fit}, \code{data_preprocessed}, \code{n_pat}, \code{K}, \code{design_info}, \code{prior}, and
\code{stan_data_list}.
}
\description{
Fits a discrete-time Bayesian model for recurrent counts and a terminal
event using gAR(1) smoothing priors on time-varying intercepts. A pre-compiled
Stan model (.rds) is loaded from the package and MCMC is run via \code{rstan::sampling()}.
}
\details{
Internally the function:
\enumerate{
\item Copies user-named columns into canonical names \code{pat_id}, \code{k_idx}, \code{A}, \code{T_obs}, \code{Y_obs}.
\item Calls \code{preprocess_data()} to order rows by (\code{pat_id}, \code{k_idx}), remap subject IDs to
consecutive integers, and, when lag terms are requested but missing, create the \code{lag_col}
within subject. Rows after the first \code{T_obs == 1} per subject are removed (the death row
itself is kept). The data are not padded to a full grid.
\item Builds design matrices from the right-hand sides of \code{formula_T} and \code{formula_Y}, excluding
the treatment column. Missing values in the model matrices are set to zero. The terminal
model uses all rows; the recurrent model uses \code{k_idx == 1} for baseline and \code{k_idx > 1}
for follow-up.
\item Loads the pre-compiled Stan model from the package and runs MCMC via \code{rstan::sampling()}.
}
}
\section{Methods (by generic)}{
\itemize{
\item \code{print(causal_recur_fit)}: Print a brief object summary.

\item \code{summary(causal_recur_fit)}: Summarize posterior parameter estimates.

\item \code{plot(causal_recur_fit)}: Display MCMC diagnostic guidance (no plot produced).

}}
\examples{
df <- data.frame(
  sid         = rep(1:2, each = 2),
  period      = rep(1:2, 2),
  event_count = c(0,1, 1,0),
  death_flag  = c(0,0, 0,1),
  trt_arm     = c(0,1, 0,1)
)
prior <- list(
  eta_beta = 0, sigma_beta = 1, rho_beta = 0.5,
  eta_gamma = 0, sigma_gamma = 1, rho_gamma = 0.5
)
\dontrun{
fit <- fit_causal_recur(
  data      = df, K = 2,
  id_col    = "sid",
  time_col  = "period",
  treat_col = "trt_arm",
  formula_T = death_flag  ~ lagYk + A,
  formula_Y = event_count ~ lagYk + A,
  prior     = prior,
  num_chains = 1, iter = 200,
  cores = 1, verbose = FALSE,
  lag_col = "lagYk"
)
print(fit)
}

}
